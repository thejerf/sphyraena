package request

// FIXME: This package needs a name other than context, goimports keeps
// resolving this to the google version.

import (
	"fmt"
	"net/http"
	"sync"
	"time"

	"github.com/thejerf/sphyraena/identity"
	"github.com/thejerf/sphyraena/identity/session"
	"github.com/thejerf/sphyraena/sphyrw"
	"github.com/thejerf/sphyraena/sphyrw/cookie"
	"github.com/thejerf/sphyraena/sphyrw/hole"
	"github.com/thejerf/sphyraena/strest"
)

// FIXME: File needs to be renamed.

type SphyraenaState struct {
	session.SessionServer

	// This is the default object to use for an unauthenticated user
	// If nil, this will automatically be set to enticate.DefaultUnauthenticated{}.
	defaultIdentity func() *identity.Identity
}

// FromStream allows the creation of requests from streams, where the
// current stream and session are already known.
func FromStream(
	session session.Session,
	stream *strest.Stream,
	handleInitialResponse func(StreamRequestResult),
) *Request {
	return &Request{
		session:               session,
		currentStream:         stream,
		isStreaming:           true,
		handleInitialResponse: handleInitialResponse,
	}
}

// Request is the Sphyraena-specific request for Sphyraena.
//
// In addition to composing *http.Request in, it has additional
// functionality for dealing with Sphyraena-specific functionality.
//
// FIXME: At the moment, this has a non-compliant context
// implementation. This should eventually be replaced by a simple
// context.Context object.
//
// FIXME: This needs to be renamed to HTTPRequest or something.
type Request struct {
	*SphyraenaState
	*RouteResult
	session session.Session
	Cookies *cookie.InCookies

	*http.Request

	// FIXME: Probably broken, use context properly instead
	values map[interface{}]interface{}

	currentStream *strest.Stream

	isStreaming bool

	// hack for now. Making it something public the user can screw with is
	// a code smell. FIXME this ought to come in the form of providing a
	// streaming context.
	// FIXME It's even worse than that because if we want to reuse this
	// context for subrequests, this isn't necessarily safe to pass
	// along. Still, as it says, hack.
	// FIXME: This can be entirely removed now, because we're going to run
	// StreamHandlers in goroutines.
	RunningAsGoroutine bool

	// This handles the initial response to the stream, which may include a
	// complete failure to initiate due to being not found, etc. FIXME:
	// Simply opening a stream directly should automatically handle this,
	// if possible, as well as the HandleStream call returning without
	// having initiated any stream.
	hrOnce                sync.Once
	handleInitialResponse func(StreamRequestResult)
}

func (c *Request) Session() session.Session {
	return c.session
}

func (c *Request) StreamResponse(srr StreamRequestResult) {
	c.hrOnce.Do(func() { c.handleInitialResponse(srr) })
}

// IsStreaming indicates whether the request is a streaming request or a
// conventional HTTP request.
func (c *Request) IsStreaming() bool {
	return c.isStreaming
}

// SetSession sets the session for the current context.
//
// Doing this will automatically .Expire the current session. This is for
// security reasons; sessions should be renewed after every session change
// (see
// https://www.owasp.org/index.php/Session_Management_Cheat_Sheet#Renew_the_Session_ID_After_Any_Privilege_Level_Change ).
// It is intended that any attempt to modify the user's permissions
// requires a new session and results in a new session authorization
// (cookie, usually).
func (c *Request) SetSession(s session.Session) {
	// note this does not manipulate cookies, because there are session
	// mechanims other than cookies.
	c.session.Expire()
	c.session = s
}

// A Sphyraena-specific context key type.
type Key string

// This is the specific context generated by the routing.
type RouteResult struct {
	// These are the capture parameters for the request, the path that
	// matched, and the remaining unmatched path for the request
	Parameters    map[string]string
	Cookies       map[string]*cookie.OutCookie
	Headers       http.Header
	PrecedingPath string
	RemainingPath string
	Holes         hole.SecurityHoles
}

// Deadline implements the Request's Deadline method, by hardcoding that there
// is no deadline.
func (c *Request) Deadline() (time.Time, bool) {
	return time.Time{}, false
}

// Done implements the Request's Done method by always returning nil.
func (c *Request) Done() <-chan struct{} {
	return nil
}

// Err implements the Request's Err method by always returning nil.
func (c *Request) Err() error {
	return nil
}

// Value returns the value the context contains for the given key. Keys
// reserved by Sphyraena itself use Sphyraena-specific types. You should
// use only your own types or built-in types as keys.
func (c *Request) Value(key interface{}) interface{} {
	return c.values[key]
}

func (c *Request) Set(key, value interface{}) {
	c.values[key] = value
}

func NewSphyraenaState(ss session.SessionServer, defaultIdentity func() *identity.Identity) *SphyraenaState {
	if defaultIdentity == nil {
		defaultIdentity = func() *identity.Identity {
			return identity.AnonymousIdentity
		}
	}

	return &SphyraenaState{
		SessionServer:   ss,
		defaultIdentity: defaultIdentity,
	}
}

// FIXME: May be the wrong name now as it grows.
// FIXME: Yes, there's a huge mess developing here between the context and
// the SPHYRW.

func (ss *SphyraenaState) NewRequest(
	rw http.ResponseWriter,
	req *http.Request,
	isStreaming bool,
) (*Request, *sphyrw.SphyraenaResponseWriter) {
	// For now, put all requests into the same session
	var failedCookies []string
	cookies, failedCookies := cookie.ParseCookies(req.Header["Cookie"],
		ss.SessionServer)
	srw := sphyrw.NewSphyraenaResponseWriter(rw)

	if len(failedCookies) != 0 {
		// temporary for debugging
		fmt.Printf("Rejecting cookies: %v\n", failedCookies)
		for _, cookieName := range failedCookies {
			cookie, err := cookie.NewNonstandardOut(cookieName, "", nil, cookie.Delete)
			if err != nil {
				continue
			}
			srw.SetCookie(cookie)
		}
	}

	return &Request{
		SphyraenaState: ss,
		Request:        req,
		session:        session.AnonymousSession,
		Cookies:        cookies,
		values:         map[interface{}]interface{}{},
		isStreaming:    isStreaming,
	}, srw
}
