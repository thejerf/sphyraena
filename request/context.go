package request

// FIXME: This package needs a name other than context, goimports keeps
// resolving this to the google version.

import (
	"fmt"
	"net/http"
	"time"

	"github.com/thejerf/sphyraena/identity"
	"github.com/thejerf/sphyraena/identity/session"
	"github.com/thejerf/sphyraena/sphyrw"
	"github.com/thejerf/sphyraena/sphyrw/cookie"
	"github.com/thejerf/sphyraena/sphyrw/hole"
	"github.com/thejerf/sphyraena/strest"
)

// FIXME: File needs to be renamed.

type SphyraenaState struct {
	session.SessionServer

	// This is the default object to use for an unauthenticated user
	// If nil, this will automatically be set to enticate.DefaultUnauthenticated{}.
	defaultIdentity func() *identity.Identity
}

// development notes:
// it would be nice if the context couldn't be meaningfully written to by
// RoutingClauses, since that's pretty much an error waiting to happen. As
// I write this, a casual examination of the Context suggests that the only
// thing that you can write to is the google Context elements, which
// suggests we might be able to wrap this simply via a conversion into a
// type that doesn't offer that functionality. Currently waiting-and-seeing
// to see what all the Context ends up with before it's all said and done.

// Request is the Sphyraena-specific request for Sphyraena.
//
// In addition to composing *http.Request in, it has additional
// functionality for dealing with Sphyraena-specific functionality.
//
// FIXME: At the moment, this has a non-compliant context
// implementation. This should eventually be replaced by a simple
// context.Context object.
//
// FIXME: This needs to be renamed to HTTPRequest or something.
type Request struct {
	*SphyraenaState
	*RouteResult
	session session.Session
	Cookies *cookie.InCookies

	*http.Request

	// FIXME: Probably broken, use context properly instead
	values map[interface{}]interface{}

	// FIXME: Used anywhere? Probably nonsensical.
	currentStream *strest.Stream

	// FIXME: Remove. Streamability is now determined by the request type.
	canStream bool

	// hack for now. Making it something public the user can screw with is
	// a code smell. FIXME this ought to come in the form of providing a
	// streaming context.
	// FIXME It's even worse than that because if we want to reuse this
	// context for subrequests, this isn't necessarily safe to pass
	// along. Still, as it says, hack.
	// FIXME: This can be entirely removed now, because we're going to run
	// StreamHandlers in goroutines.
	RunningAsGoroutine bool
}

// Session retrieves the current session for the session.
func (c *Request) Session() session.Session {
	return c.session
}

// CanHandleStream returns whether or not this request can handle a stream
// going back to it.
//
// Requests that come in through normal HTTP can not be streamed, or at
// least, not in the sense that Sphyraena means. ("Normal" HTTP streaming,
// where you just send a request slowly over time, is supported in the same
// way net/http supports it.) Only requests that come in a way that is
// known by the framework to be able to handle streams can be streamed.
func (c *Request) CanHandleStream() bool {
	return c.canStream
}

// SetSession sets the session for the current context.
//
// Doing this will automatically .Expire the current session. This is for
// security reasons; sessions should be renewed after every session change
// (see
// https://www.owasp.org/index.php/Session_Management_Cheat_Sheet#Renew_the_Session_ID_After_Any_Privilege_Level_Change ).
// It is intended that any attempt to modify the user's permissions
// requires a new session and results in a new session authorization
// (cookie, usually).
func (c *Request) SetSession(s session.Session) {
	// note this does not manipulate cookies, because there are session
	// mechanims other than cookies.
	c.session.Expire()
	c.session = s
}

// A Sphyraena-specific context key type.
type Key string

// This is the specific context generated by the routing.
type RouteResult struct {
	// These are the capture parameters for the request, the path that
	// matched, and the remaining unmatched path for the request
	Parameters    map[string]string
	Cookies       map[string]*cookie.OutCookie
	Headers       http.Header
	PrecedingPath string
	RemainingPath string
	Holes         hole.SecurityHoles
}

// Deadline implements the Request's Deadline method, by hardcoding that there
// is no deadline.
func (c *Request) Deadline() (time.Time, bool) {
	return time.Time{}, false
}

// Done implements the Request's Done method by always returning nil.
func (c *Request) Done() <-chan struct{} {
	return nil
}

// Err implements the Request's Err method by always returning nil.
func (c *Request) Err() error {
	return nil
}

// Value returns the value the context contains for the given key. Keys
// reserved by Sphyraena itself use Sphyraena-specific types. You should
// use only your own types or built-in types as keys.
func (c *Request) Value(key interface{}) interface{} {
	return c.values[key]
}

func (c *Request) Set(key, value interface{}) {
	c.values[key] = value
}

func NewSphyraenaState(ss session.SessionServer, defaultIdentity func() *identity.Identity) *SphyraenaState {
	if defaultIdentity == nil {
		defaultIdentity = func() *identity.Identity {
			return identity.AnonymousIdentity
		}
	}

	return &SphyraenaState{
		SessionServer:   ss,
		defaultIdentity: defaultIdentity,
	}
}

// FIXME: May be the wrong name now as it grows.
// FIXME: Yes, there's a huge mess developing here between the context and
// the SPHYRW.

func (ss *SphyraenaState) NewRequest(
	rw http.ResponseWriter,
	req *http.Request,
	canStream bool,
) (*Request, *sphyrw.SphyraenaResponseWriter) {
	// For now, put all requests into the same session
	var failedCookies []string
	cookies, failedCookies := cookie.ParseCookies(req.Header["Cookie"],
		ss.SessionServer)
	srw := sphyrw.NewSphyraenaResponseWriter(rw)

	if len(failedCookies) != 0 {
		// temporary for debugging
		fmt.Printf("Rejecting cookies: %v\n", failedCookies)
		for _, cookieName := range failedCookies {
			cookie, err := cookie.NewNonstandardOut(cookieName, "", nil, cookie.Delete)
			if err != nil {
				continue
			}
			srw.SetCookie(cookie)
		}
	}

	return &Request{
		SphyraenaState: ss,
		Request:        req,
		session:        session.AnonymousSession,
		Cookies:        cookies,
		values:         map[interface{}]interface{}{},
		canStream:      canStream,
	}, srw
}
