package sample

import (
	"fmt"
	"net/http"
	"strconv"
	"time"

	"github.com/thejerf/abtime"
	"github.com/thejerf/sphyraena/context"
	"github.com/thejerf/sphyraena/strest"
	"github.com/thejerf/sphyraena/strest/orw"
)

const (
	tickID = iota
)

// Need to figure out why setting incr -1 crashes the subscription out entirely
// one can argue that you've lost the right to the subscription, but it
// should not crash the entire REST server loop.

// TestValue is used to wrap the result of the TestData in a nice JSON wrapper.
type TestValue struct {
	Value uint64 `json:"value"`
}

// TestREST is a sample REST implementation that does a little bit of
// everything, from scratch. It's currently left in the "core" code so
// we can do coverage testing on it, but theoretically it ought to be an
// example.
//
// TestREST accepts input, emits events, emits events via external
// prodding, and can also be crashed, just to make sure we handle
// everything correctly.
type TestREST struct {
	current        uint64
	incomingTicker <-chan time.Time
	incomingTweaks chan uint64
	streamType     strest.StreamType
	*strest.StreamInfo
}

func MakeTestREST(context *context.Context) (strest.StreamingREST, error) {
	// FIXME: see about finding an unmarshaler here
	initialStr := context.FormValue("initial")
	initial := uint64(0)

	if initialStr != "" {
		parsed, err := strconv.ParseUint(initialStr, 10, 64)
		if err != nil {
			// FIXME: Figure out what to do about this. A hard-coded
			// set of REST resources that know how to return 404s or
			// something?
			panic("What do we do here?")
		}
		initial = parsed
	}

	streamType := strest.SimpleStream
	if context.FormValue("nostream") != "" {
		streamType = strest.NoStream
	}

	// FIXME: OK, I've established to my satisfaction the whole "declare a
	// unique StreamingREST" thing so that calling this is perfectly free
	// to start up a stream, but now I need to get the stream manager
	testRest := NewTestREST(initial, abtime.NewRealTime(), streamType)
	testRest.StreamInfo = context.NewStreamInfo()
	go testRest.Serve()
	fmt.Println("Started serving")
	return testRest, nil
}

func NewTestREST(initial uint64, at abtime.AbstractTime, streamType strest.StreamType) *TestREST {
	tr := &TestREST{
		current:        initial,
		incomingTicker: at.NewTicker(time.Second, tickID).Channel(),
		incomingTweaks: make(chan uint64),
		streamType:     streamType,
	}
	return tr
}

// Poke tells the TestREST to increase the number it is tracking by
// the given incr. If incr is 0, the TestREST will terminate. If incr is
// 99999, TestREST panics.
func (sir *TestREST) Poke(incr uint64) {
	sir.incomingTweaks <- incr
}

func (sir *TestREST) Serve() {
	fmt.Println("Starting serving TestREST")
	defer func() {
		if r := recover(); r != nil {
			// in a real REST server, log something
			fmt.Println("Crashed a TestREST with", r)
		}
		// StreamingRESTs must make sure to terminate their stream when
		// they terminate.
		sir.TerminateStream()
	}()

	for {
		select {
		case <-sir.incomingTicker:
			sir.current++
			sir.SendEvent(TestValue{sir.current})
		case incr := <-sir.incomingTweaks:
			if incr == 0 {
				return
			}
			if incr == 99999 {
				panic("You said the magic number!")
			}
			sir.current += incr
			sir.SendEvent(TestValue{sir.current})
		case req := <-sir.Requests:
			fmt.Println("Getting a request in:", req)
			httpReq := req.Request
			switch httpReq.Method {
			case "GET":
				fmt.Println("Get request:", sir.current)
				orw.WriteJSON(req.ObjectResponseWriter, TestValue{sir.current})
				req.Finish(sir.StreamInfo, strest.SimpleStream, sir.SourceID(), req.RequestID)
				fmt.Println("Finished request")
			case "POST":
				err := httpReq.ParseForm()
				// FIXME: Need to set this up so that a response
				// is always provided
				// FIXME: Need to deal with running out of subscriptions,
				// this is an enormous goroutine leak right now.
				if err != nil {
					// FIXME: Provide an all-in-one error in here
					http.Error(req.ObjectResponseWriter, "Form unparsable", 500)
					// FIXME: Interface away the stream info so we're
					// not resolving into the object's members
					req.Finish(sir.StreamInfo, strest.NoStream, sir.SourceID(), req.RequestID)
				} else {
					incrStr := httpReq.PostForm.Get("incr")
					if incrStr != "" {
						i, err := strconv.ParseUint(incrStr, 10, 64)
						if err == nil {
							// when refactored, it would be helpful to make
							// it so the proper order is encouraged strongly:

							// 1. do whatever teh command told you to do
							sir.current += i

							// 2. perform your response
							orw.WriteJSON(req.ObjectResponseWriter, TestValue{sir.current})
							req.Finish(sir.StreamInfo, strest.NoStream, sir.SourceID(), req.RequestID)

							// 3. Emit any new events that may be necessary.
							sir.SendEvent(TestValue{sir.current})
						} else {
							req.Finish(sir.StreamInfo, strest.NoStream,
								sir.SourceID(), req.RequestID)
						}
					} else {
						req.Finish(sir.StreamInfo, strest.NoStream, sir.SourceID(), req.RequestID)
					}
				}
			default:
				http.Error(req.ObjectResponseWriter, "Method not implemented", 405)
				req.Finish(sir.StreamInfo, strest.NoStream, sir.SourceID(), req.RequestID)
			}
		}
	}
}

func (sir *TestREST) Handle(srr *strest.StreamingRESTRequest) {
	fmt.Println("-- Handling --", srr)
	sir.Requests <- srr
	fmt.Println("Handled")
}
